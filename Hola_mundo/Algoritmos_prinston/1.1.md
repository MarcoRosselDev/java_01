# Modelos básicos de programación

Nuestro estudio de algoritmos se basa en implementarlos como programas escritos en el lenguaje de programación Java.   
Lo hacemos por varias razones:  
- Nuestros programas son descripciones concisas, elegantes y completas de algoritmos.
- Puede ejecutar los programas para estudiar las propiedades de los algoritmos. 
- Puede aplicar los algoritmos inmediatamente en sus aplicaciones. 

Estas son ventajas importantes y significativas sobre las alternativas de trabajar con descripciones de algoritmos en inglés.  

Una posible desventaja de este enfoque es que debemos trabajar con un lenguaje de programación específico,  
lo que posiblemente dificulte separar la idea del algoritmo de los detalles de su implementación.   
Nuestras implementaciones están diseñadas para mitigar esta dificultad mediante el uso de estructuras de programación presentes en muchos lenguajes modernos y necesarias para describir adecuadamente los algoritmos.   

Usamos solo un pequeño subconjunto de Java.  
Si bien no llegamos a definir formalmente el subconjunto que utilizamos, observará que usamos relativamente pocas construcciones de Java y que enfatizamos las que se encuentran en muchos lenguajes de programación modernos.   
El código que presentamos está completo y esperamos que lo descargue y lo ejecute en nuestros datos de prueba o en los datos de prueba que elija.   

Nos referimos a las construcciones de programación, bibliotecas de software y características del sistema operativo que utilizamos para implementar y describir algoritmos como nuestro modelo de programación.  
En esta sección y en la Sección 1.2, describimos completamente este modelo de programación.   
El tratamiento es independiente y está destinado principalmente a la documentación y como referencia para la comprensión del código del libro.   
El modelo que describimos es el mismo que se presenta en nuestro libro Introducción a la Programación en Java: Un Enfoque Interdisciplinario, que ofrece una introducción más pausada al material.   

Como referencia, la figura de la página siguiente muestra un programa Java completo que ilustra muchas de las características básicas de nuestro modelo de programación.  
Usamos este código como ejemplo al analizar las características del lenguaje, pero lo analizamos en detalle en la página 46 (implementa un algoritmo clásico conocido como búsqueda binaria y lo prueba para una aplicación conocida como filtrado de lista blanca).  
Asumimos que tiene experiencia programando en algún lenguaje moderno, por lo que probablemente reconocerá muchas de estas características en este código.   
Se incluyen referencias a las páginas en las anotaciones para ayudarle a encontrar respuestas a cualquier pregunta que pueda tener.   
Dado que nuestro código es algo estilizado y nos esforzamos por usar de forma consistente diversos modismos y construcciones de Java, vale la pena, incluso para programadores Java con experiencia, leer la información de esta sección.  


<source media="(prefers-color-scheme: dark)" srcset="./ejemplo_1_java_structure_dark.png">
<source media="(prefers-color-scheme: light)" srcset="./ejemplo_1_java_structure_light.png">
<img alt="a" src="./ejemplo_1_java_structure_dark.png">


********

## Estructura básica de un programa java

Un programa Java (clase) es una biblioteca de métodos estáticos (funciones) o una definición de tipo de datos.   
Para crear bibliotecas de métodos estáticos y definiciones de tipos de datos, utilizamos los siguientes cinco componentes, la base de la programación en Java y muchos otros lenguajes modernos:  
- Los tipos de datos primitivos definen con precisión el significado de términos como entero, número real y valor booleano dentro de un programa informático.   
 Su definición incluye el conjunto de valores posibles y las operaciones con dichos valores, que pueden combinarse en expresiones similares a las expresiones matemáticas que definen valores.
- Las sentencias permiten definir un cálculo creando y asignando valores a variables, controlando el flujo de ejecución o generando efectos secundarios.   
  Utilizamos seis tipos de sentencias: 
   - declaraciones
   - asignaciones
   - condicionales
   - bucles
   - llamadas 
   - retornos 

- Los arrays permiten trabajar con múltiples valores del mismo tipo. 
- Los métodos estáticos permiten encapsular y reutilizar código, y desarrollar programas como un conjunto de módulos independientes.  
- Las cadenas son secuencias de caracteres. Algunas operaciones con ellas están integradas en Java.
- La entrada/salida establece la comunicación entre los programas y el mundo exterior.  
- La abstracción de datos extiende la encapsulación y la reutilización para permitirnos definir tipos de datos no primitivos, apoyando así la programación orientada a objetos.  

En esta sección, consideraremos los primeros cinco por orden.  
La abstracción de datos es el tema de la siguiente sección.   
Ejecutar un programa Java implica interactuar con un sistema operativo o un entorno de desarrollo de programas.  
Para mayor claridad y economía, describimos estas acciones en términos de una terminal virtual, donde interactuamos con los programas escribiendo comandos al sistema.   
Consulte el sitio web del libro para obtener detalles sobre el uso de una terminal virtual en su sistema o para obtener información sobre el uso de uno de los muchos entornos de desarrollo de programas más avanzados disponibles en los sistemas modernos.  
Por ejemplo, BinarySearch consta de dos métodos estáticos: rank() y main().  
El primer método estático, rank(), consta de cuatro sentencias: dos declaraciones, un bucle (que a su vez es una asignación y dos condicionales) y un retorno.  
El segundo, main(), consta de tres sentencias: una declaración, una llamada y un bucle (que a su vez es una asignación y un condicional).  
Para invocar un programa Java, primero lo compilamos con el comando javac y luego lo ejecutamos con el comando java.   
Por ejemplo, para ejecutar BinarySearch, primero escribimos el comando javac BinarySearch.java (que crea un archivo BinarySearch.class que contiene una versión de nivel inferior del programa en código de bytes de Java en el archivo BinarySearch.class).   
Luego, escribimos java BinarySearch (seguido de un nombre de archivo de lista blanca) para transferir el control a la versión de código de bytes del programa.   
Para desarrollar una base que nos permita comprender el efecto de estas acciones, a continuación consideramos en detalle los tipos de datos y expresiones primitivos, los distintos tipos de sentencias Java, matrices, métodos estáticos, cadenas y entrada/salida.  

********

## Tipos de datos y expresiones primitivos.  

Un tipo de dato es un conjunto de valores y un conjunto de operaciones sobre dichos valores.   Comenzamos considerando los siguientes cuatro tipos de datos primitivos, que constituyen la base del lenguaje Java:  
- Integers, con operaciones aritméticas (int)
- Números reales, también con operaciones aritméticas (double)
- Booleans, el conjunto de valores {true, false} con operaciones lógicas (boolean)
- Characters, los caracteres alfanuméricos y los símbolos que se escriben (char)

A continuación, consideramos los mecanismos para especificar valores y operaciones para estos tipos.  
Un programa Java manipula variables nombradas con identificadores.  
Cada variable está asociada a un tipo de dato y almacena uno de los valores permitidos.  
En código Java, utilizamos expresiones, similares a las expresiones matemáticas habituales, para aplicar las operaciones asociadas a cada tipo.   
Para los tipos primitivos, utilizamos identificadores para referirnos a las variables, símbolos de operador como + - * / para especificar operaciones, literales como 1 o 3.14 para especificar valores y expresiones como (x + 2.236)/2 para especificar operaciones sobre valores.  
El propósito de una expresión es definir uno de los valores del tipo de dato.  

<source media="(prefers-color-scheme: dark)" srcset="./ejemplo_2_data_types_dark.png">
<source media="(prefers-color-scheme: light)" srcset="./ejemplo_2_data_types_light.png">
<img alt="a" src="./ejemplo_2_data_types_dark.png">

Para definir un tipo de dato, solo necesitamos especificar los valores y el conjunto de operaciones sobre esos valores.  
Esta información se resume en la tabla a continuación para los tipos de datos int, double, boolean y char de Java.  
Estos tipos de datos son similares a los tipos de datos básicos que se encuentran en muchos lenguajes de programación.  
Para int y double, las operaciones son operaciones aritméticas comunes; para boolean, son operaciones lógicas comunes.  
Es importante tener en cuenta que +, -, * y / están sobrecargados: el mismo símbolo especifica operaciones en múltiples tipos diferentes, según el contexto.   
La propiedad clave de estas operaciones primitivas es que una operación que involucra valores de un tipo dado tiene un valor de ese tipo.  
Esta regla resalta la idea de que a menudo trabajamos con valores aproximados, ya que a menudo el valor exacto que parecería estar definido por la expresión no es un valor del tipo.   
Por ejemplo, 5/3 tiene el valor 1 y 5.0/3.0 tiene un valor muy cercano a 1.6666666666667, pero ninguno de estos es exactamente igual a 5/3.   
Esta tabla no está completa; analizamos algunos operadores adicionales y diversas situaciones excepcionales que ocasionalmente debemos considerar en las preguntas y respuestas al final de esta sección.

<source media="(prefers-color-scheme: dark)" srcset="ejemplo_3_primitive_Data_type_dark.png">
<source media="(prefers-color-scheme: light)" srcset="ejemplo_3_primitive_Data_type_light.png">
<img alt="a" src="ejemplo_3_primitive_Data_type_dark.png">

**Expresiones:**.  
Como se ilustra en la tabla al final de la página anterior, las expresiones típicas son infijas: un literal (o una expresión), seguido de un operador, seguido de otro literal (u otra expresión).  
Cuando una expresión contiene más de un operador, el orden en que se aplican suele ser significativo, por lo que las siguientes convenciones de precedencia forman parte de la especificación del lenguaje Java: Los operadores * y / (y %) tienen mayor precedencia que (se aplican antes que) los operadores + y -; entre los operadores lógicos, ! es el de mayor precedencia, seguido de && y ||. Generalmente, los operadores con la misma precedencia se aplican de izquierda a derecha.  
Al igual que en las expresiones aritméticas estándar, se pueden usar paréntesis para anular estas reglas.   
Dado que las reglas de precedencia varían ligeramente entre lenguajes, usamos paréntesis y, de lo contrario, nos esforzamos por evitar la dependencia de las reglas de precedencia en nuestro código.  

**Conversión de tipo**.  
Los números se convierten automáticamente a un tipo más inclusivo si no se pierde información.  
Por ejemplo, en la expresión 1 + 2.5, el 1 se convierte al valor doble 1.0 y la expresión se evalúa como el valor doble 3.5.  
Una conversión es un nombre de tipo entre paréntesis dentro de una expresión, una directiva para convertir el siguiente valor en un valor de ese tipo.   
Por ejemplo, (int) 3.7 es 3 y (double) 3 es 3.0. Tenga en cuenta que la conversión a un int es truncamiento en lugar de redondeo; las reglas para la conversión dentro de expresiones complejas pueden ser complejas, y las conversiones deben usarse con moderación y cuidado.   
Una práctica recomendada es usar expresiones que involucren literales o variables de un solo tipo.  

**Comparaciones**.  
Los siguientes operadores comparan dos valores del mismo tipo y producen un valor booleano: igual (==), distinto (!=), menor que (<), menor o igual (<=), mayor que (>) y mayor o igual (>=).  
Estos operadores se conocen como operadores de tipo mixto porque su valor es booleano, no el tipo de los valores que se comparan.   
Una expresión con un valor booleano se conoce como expresión booleana.   
Estas expresiones son componentes esenciales de las sentencias condicionales y de bucle, como veremos.  

**Otros tipos primitivos**.  
El int de Java tiene 232 valores diferentes por diseño, por lo que puede representarse en una palabra de máquina de 32 bits (muchas máquinas tienen palabras de 64 bits hoy en día, pero el int de 32 bits persiste).  
De igual forma, el doble estándar especifica una representación de 64 bits.  
Estos tamaños de tipos de datos son adecuados para aplicaciones típicas que utilizan enteros y números reales.   
Para mayor flexibilidad, Java ofrece cinco tipos de datos primitivos adicionales:  
- 64-bit integers, con operaciones aritméticas (long)  
- 16-bit integers, con operaciones aritméticas (short)  
- 16-bit characters, con operaciones aritméticas (char)  
- 8-bit integers, con operaciones aritméticas (byte)  
- 32-bit single-precision real numbers, también con operaciones aritméticas (float)   

En este libro utilizamos con mayor frecuencia operaciones aritméticas int y double, por lo que no consideraremos las otras (que son muy similares) con más detalle aquí.  

**Declaraciones (Statements)**.  
Un programa Java se compone de sentencias que definen el cálculo mediante la creación y manipulación de variables, la asignación de valores de tipos de datos y el control del flujo de ejecución de dichas operaciones.  
Las sentencias suelen organizarse en bloques, secuencias de sentencias entre llaves. 

- **Declarations** crean variables de un tipo específico y las nombran con identificadores.
- **Assignments** asocian un valor de tipo de dato (definido por una expresión) con una variable. Java también cuenta con varios lenguajes de asignación implícitos para cambiar el valor de un valor de tipo de dato con respecto a su valor actual, como incrementar el valor de una variable entera.
- **Conditionals** permiten un cambio simple en el flujo de ejecución: ejecutan las sentencias en uno de dos bloques, según una condición especificada.
- **Loops** permiten un cambio más profundo en el flujo de ejecución: ejecutan las sentencias en un bloque siempre que se cumpla una condición dada.
- **Calls and returns** se relacionan con métodos estáticos (véase la página 22), que ofrecen otra forma de cambiar el flujo de ejecución y organizar el código.

**Declaraciones (Declarations)**.  
Una declaración asocia el nombre de una variable con un tipo en tiempo de compilación. Java requiere el uso de declaraciones para especificar los nombres y tipos de las variables.  
De esta manera, se especifican explícitamente los cálculos.  
Se dice que Java es un lenguaje fuertemente tipado porque su compilador verifica la consistencia (por ejemplo, no permite multiplicar un booleano por un doble).  
Las declaraciones pueden aparecer en cualquier lugar antes del primer uso de una variable; normalmente, se colocan en el momento del primer uso.  
El ámbito "scope" de una variable es la parte del programa donde se define.  
Generalmente, el ámbito de una variable se compone de las declaraciones que siguen a la declaración en el mismo bloque que esta.  

**Asignaciones (Assignments)**.  
Una sentencia de asignación asocia un valor de tipo de dato (definido por una expresión) a una variable.  
Al escribir c = a + b en Java, no se expresa una igualdad matemática, sino una acción:  
establecer el valor de la variable c como el valor de a más el valor de b.  
Es cierto que c es matemáticamente igual a "a + b" inmediatamente después de ejecutar la sentencia de asignación, pero el objetivo de la sentencia es cambiar el valor de c (si es necesario).   
El lado izquierdo de una sentencia de asignación debe ser una sola variable; el lado derecho puede ser una expresión arbitraria que genere un valor del tipo.

**Condicionales**.  
La mayoría de los cálculos requieren acciones diferentes para distintas entradas.  
Una forma de expresar estas diferencias en Java es la sentencia if:

````javascript
if ( <boolean epxression> ) { <block statements> }
else { <block statements> }
````
Permite elegir entre dos bloques de sentencias alternativos.  

**Loops**.  
Muchos cálculos son inherentemente repetitivos.  
La construcción básica de Java para gestionar estos cálculos tiene el siguiente formato:

`````java
while (<boolean expression>) { <block statements> }
`````
La sentencia while tiene la misma forma que la sentencia if (la única diferencia es el uso de la palabra clave while en lugar de if), pero su significado es bastante distinto.  
Es una instrucción a la computadora para que se comporte de la siguiente manera: si la expresión booleana es falsa, no hacer nada; si la expresión booleana es verdadera, ejecutar la secuencia de sentencias del bloque (igual que con if), pero luego comprobar la expresión booleana de nuevo, ejecutar la secuencia de sentencias del bloque de nuevo si la expresión booleana es verdadera y continuar mientras la expresión booleana sea verdadera.  
Nos referimos a las sentencias del bloque en un bucle como el cuerpo del bucle.

**Break and continue**.  
Algunas situaciones requieren un flujo de control ligeramente más complejo que el proporcionado por las sentencias if y while básicas.  
Por consiguiente, Java admite dos sentencias adicionales para su uso en bucles while:

- La sentencia break, que sale inmediatamente del bucle.  
- La sentencia continue, que inicia inmediatamente la siguiente iteración del bucle.  

Rara vez usamos estas declaraciones en el código de este libro (y muchos programadores nunca las usan), pero simplifican considerablemente el código en ciertos casos.  

**Shortcut notations (Notaciones abreviadas)**.  
Hay varias maneras de expresar un cálculo dado;  
buscamos un código claro, elegante y eficiente.  
Este código suele aprovechar las siguientes notaciones abreviadas, ampliamente utilizadas (y que se encuentran en muchos lenguajes, no solo en Java). 

**Inicialización de declaraciones**.  
Podemos combinar una declaración con una asignación para inicializar una variable al mismo tiempo que se declara (crea).  
Por ejemplo, el código int i = 1; crea una variable int llamada i y le asigna el valor inicial 1. 
Una buena práctica es usar este mecanismo cerca del primer uso de la variable (para limitar el alcance).  

**Asignaciones implícitas**.  
Los siguientes atajos están disponibles cuando nuestro propósito es modificar el valor de una variable con respecto a su valor actual:  

- Operadores de incremento/decremento: i++ es igual a i = i + 1 y tiene el valor i en una expresión.   
 De forma similar, i-- es igual a i = i - 1. Los códigos ++i y --i son iguales, excepto que el valor de la expresión se toma después del incremento/decremento, no antes. 
- Otras operaciones compuestas:  
 Anteponer un operador binario al = en una asignación equivale a usar la variable de la izquierda como primer operando.  
Por ejemplo, el código i/=2; es equivalente al código i = i/2;. Nótese que i += 1; tiene el mismo efecto que i = i+1; (e i++).

**Bloques de una sola sentencia**.  
Si un bloque de sentencias en un condicional o un bucle tiene solo una sentencia, se pueden omitir las llaves.

**For notation**.  
Muchos bucles siguen este esquema: inicializan una variable de índice con un valor determinado y luego usan un bucle while para probar una condición de continuación de bucle que involucra la variable de índice, donde la última instrucción del bucle while incrementa la variable de índice.   
Estos bucles se pueden expresar de forma compacta con la notación for de Java:

````java
for (<Inicialización>; <expresion boleana>; <incrementacion>)
{
 <bloque de codigo>
}
// Este código es, con sólo unas pocas excepciones, equivalente a

<Inicialización>;
while (<expresion boleana>)
{
 <bloque de codigo>
 <incrementacion>;
}
````
Usamos bucles for para apoyar este lenguaje de programación de inicialización e incremento.  

<source media="(prefers-color-scheme: dark)" srcset="ejemplo_4_statements_dark.png">
<source media="(prefers-color-scheme: light)" srcset="ejemplo_4_statements_light.png">
<img alt="a" src="ejemplo_4_statements_dark.png">

**Arrays**  
Una matriz almacena una secuencia de valores del mismo tipo.  
No solo queremos almacenar valores, sino también acceder a cada valor individual.   
El método que utilizamos para referirnos a los valores individuales de una matriz es numerarlos e indexarlos.  
Si tenemos N valores, los consideramos numerados de 0 a N1.  
Luego, podemos especificar uno de ellos inequívocamente en código Java usando la notación a[i] para referirnos al i-ésimo valor de cualquier valor de i de 0 a N-1. Esta construcción de Java se conoce como matriz unidimensional.  

**Creación e inicialización de un array**.  
Crear un array en un programa Java implica tres pasos distintos:

- Declarar el nombre y el tipo de la matriz.
- Crear la matriz.
- Inicializar los valores de la matriz.

Para declarar el array, se debe especificar un nombre y el tipo de datos que contendrá.  
Para crearlo, se debe especificar su longitud (el número de valores).  
Por ejemplo, el código de "formato largo" que se muestra a la abajo crea un array de N números de tipo double, todos inicializados a 0.0.  
La primera instrucción es la declaración del array.  
Es igual que la declaración de una variable del tipo primitivo correspondiente, excepto por los corchetes que siguen al nombre del tipo, que especifican que estamos declarando un array.  
La palabra clave new en la segunda instrucción es una directiva de Java para crear el array.  
La razón por la que necesitamos crear arrays explícitamente en tiempo de ejecución es que el compilador de Java no puede saber cuánto espacio reservar para el array en tiempo de compilación (como sí puede hacerlo para valores de tipo primitivo).   
La instrucción for inicializa los N valores del array. Este código establece todas las entradas del array en el valor 0.0.  
Al comenzar a escribir código que utiliza un array, debe asegurarse de que su código lo declare, lo cree y lo inicialice.  
Omitir uno de estos pasos es un error común de programación.

<source media="(prefers-color-scheme: dark)" srcset="ejemplo_5_array_dark.png">
<source media="(prefers-color-scheme: light)" srcset="ejemplo_5_array_light.png">
<img alt="a" src="ejemplo_5_array_dark.png">

**Forma abreviada**.  
Para ahorrar código, solemos aprovechar la convención de inicialización de arrays predeterminada de Java y combinar los tres pasos en una sola sentencia, como en el código de "forma abreviada" de nuestro ejemplo.  
El código a la izquierda del signo igual constituye la declaración;  
el código a la derecha, la creación.  
El bucle for es innecesario en este caso porque el valor inicial predeterminado de las variables de tipo double en un array de Java es 0.0, pero sería necesario si se deseara un valor distinto de cero.  
El valor inicial predeterminado es cero para tipos numéricos y falso para tipos booleanos.  
La tercera opción mostrada en nuestro ejemplo consiste en especificar los valores de inicialización en tiempo de compilación, enumerando los valores literales entre llaves, separados por comas.  

**Uso de un array**.  
El código típico de procesamiento de arrays se muestra en la página 21.  
Tras declarar y crear un array, se puede hacer referencia a cualquier valor individual en cualquier lugar donde se usaría un nombre de variable en un programa, encerrando un índice entero entre corchetes después del nombre del array.  
Una vez creado un array, su tamaño es fijo.  
Un programa puede hacer referencia a la longitud de un array a[] con el código a.length.  
El último elemento de un array a[] siempre es a[a.length-1]. Java realiza una comprobación automática de límites:  
si se ha creado un array de tamaño N y se utiliza un índice cuyo valor es menor que 0 o mayor que N-1, el programa terminará con una excepción de tiempo de ejecución ArrayOutOfBoundsException. 

**Aliasing**.  
Tenga en cuenta que el nombre de un array se refiere al array completo; si asignamos un nombre de array a otro, ambos se refieren al mismo array, como se ilustra en el siguiente fragmento de código.  

`````java
int[] a = new int[N];
...
a[i] = 1234;
...
int[] b = a;
...
b[i] = 5678; // a[i] is now 5678.

`````

Esta situación se conoce como alias y puede provocar errores sutiles.  
Si su intención es crear una copia de un array, deberá declarar, crear e inicializar un nuevo array y luego copiar todas las entradas del array original al nuevo, como en el tercer ejemplo de la página 21.  

**Arrays bidimensionales**.  
En Java, una matriz bidimensional es una matriz de matrices unidimensionales.  
Una matriz bidimensional puede ser irregular (sus matrices pueden tener diferentes longitudes), pero normalmente trabajamos con (para los parámetros apropiados M y N) matrices bidimensionales M por N, que son matrices de M filas, cada una de longitud N (por lo que también tiene sentido referirse a la matriz como si tuviera N columnas).  
Extender las construcciones de matrices de Java para manejar matrices bidimensionales es sencillo.  
Para hacer referencia a la entrada en la fila i y la columna j de una matriz bidimensional a[][], usamos la notación a[i][j]; para declarar una matriz bidimensional, añadimos otro par de corchetes; y para crear la matriz, especificamos el número de filas seguido del número de columnas después del nombre del tipo (ambos entre corchetes), como se indica a continuación: 

`````java
double[][] a = new double[M][N];
`````
Nos referimos a este tipo de matriz como una matriz M por N.  
Por convención, la primera dimensión es el número de filas y la segunda, el número de columnas.  
Al igual que con las matrices unidimensionales, Java inicializa todas las entradas en las matrices de tipos numéricos a cero y en las matrices de valores booleanos a falso.  
La inicialización predeterminada de las matrices bidimensionales es útil porque oculta más código que en las matrices unidimensionales.    
El siguiente código es equivalente al lenguaje de creación e inicialización de una sola línea que acabamos de considerar: 

`````java
double[][] a;
a = new double[M][N];
for (int i = 0; i < M; i++)
     for (int j = 0; j < N; j++)
        a[i][j] = 0.0;
`````

Este código es superfluo cuando se inicializa a cero, pero los bucles for anidados son necesarios para inicializar a otros valores.  

<source media="(prefers-color-scheme: dark)" srcset="ejemplo_6_proceso_array_dark.png">
<source media="(prefers-color-scheme: light)" srcset="ejemplo_6_proceso_array_light.png">
<img alt="a" src="ejemplo_6_proceso_array_dark.png">